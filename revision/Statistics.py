# used for generating heatmap of results from two models
# the contour figure is generated by MATLAB based on the heatmap generated there
# no need to read it if you want to know the tracing algorithm

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm


root_dir = 'D:/Yi Lab/Tracing by DL/results/paper'
save_folder = 'heatmap_n=1' # unet validation ours SBD DIC --------
# save_folder = 'heatmap'

# Load data
# path = Path(root_dir + '/' + 'statistics.txt')
path = Path(root_dir + '/' + 'statistics_n=1.txt')
data = instance_information = np.loadtxt(path)


# Heatmap plot
def Heatmap(id, xdata, ydata, bins, xlabel, ylabel, title, log = True, cmap = 'hot'):

    # range = [[xmin, xmax], [ymin, ymax]]

    # region = [[0, 1], [0, 1]]
    x_max = np.max([np.max(xdata),1])
    y_max = np.max([np.max(ydata),1])
    region = [[0, x_max], [0, y_max]]


    heatmap, xedges, yedges = np.histogram2d(xdata, ydata, bins = bins, range = region)
    # save heatmap
    path = Path(root_dir + '/'+ save_folder + '/' + xlabel + '_vs_' + ylabel + '_bins_'+str(bins) + '.txt')
    np.savetxt(path, np.flip(np.transpose(heatmap),0), fmt = '%d')

    extent = [xedges[0], xedges[-1], yedges[0], yedges[-1]]


    fig = plt.figure(id)
    plt.clf()
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    ax = fig.gca()
    if x_max > 1:
        ax.set_xticks(np.arange(0, x_max, 1))
        ax.set_yticks(np.arange(0, y_max, 1))
    else:
        ax.set_xticks(np.arange(0, x_max, 0.1))
        ax.set_yticks(np.arange(0, y_max, 0.1))
    plt.grid()
    if log:
        log_name = 'log10'
        # decide use which map
        if cmap == 'hot':
            plt.imshow(heatmap.T, extent = extent, origin = 'lower', cmap = plt.cm.hot, norm = LogNorm(vmin = 1, vmax = 10))
        else:
            plt.imshow(heatmap.T, extent = extent, origin = 'lower', norm = LogNorm(vmin = 1, vmax = 10))
    else:
        log_name = 'linear'
        if cmap == 'hot':
            plt.imshow(heatmap.T, extent = extent, origin = 'lower', cmap = plt.cm.hot)
        else:
            plt.imshow(heatmap.T, extent = extent, origin = 'lower')
    plt.colorbar()
    plt.title(title)

    # add text
    for y in range(heatmap.T.shape[0]):
        for x in range(heatmap.T.shape[1]):
            # black text if heatmap value >= 6 (based on hot colormap, you can change it according to your colormap)
            if heatmap.T[y, x] >= 6:
                plt.text((x + 0.5)/heatmap.T.shape[0] * x_max, (y + 0.5) / heatmap.T.shape[1] * y_max, '%d' % heatmap.T[y, x],
                 horizontalalignment = 'center',
                 verticalalignment = 'center',
                 fontsize=6,
                 )
            elif heatmap.T[y, x] == 0:
                pass
            # white text if heatmap value < 6
            else:
                plt.text((x + 0.5)/heatmap.T.shape[0] * x_max, (y + 0.5) / heatmap.T.shape[1] * y_max, '%d' % heatmap.T[y, x],
                 horizontalalignment='center',
                 verticalalignment='center',
                 c = 'white',
                 fontsize=6,
                 )

    # draw line
    plt.plot([0.3, 0.3], [0, y_max], 'r-', lw=2)
    plt.plot([0, x_max], [0.3, 0.3], 'm-', lw=2)

    #root_dir set global
    path = Path(root_dir + '/'+ save_folder + '/' + xlabel + '_vs_' + ylabel + '_bins_'+str(bins)+'_'+ log_name+ '_' + title + '.png')
    plt.savefig(path, dpi=300)


# Heatmap(1,data[:,1], data[:,5], 20,'UNET','Ours','Prediction-center best dice',log=False,cmap='default')
# Heatmap(2,data[:,1], data[:,3], 20,'UNET','Validation','Prediction-center best dice',log=False,cmap='default')
# Heatmap(3,data[:,3], data[:,5], 20,'Validation','Ours','Prediction-center best dice',log=False,cmap='default')
# Heatmap(4,data[:,2], data[:,6], 20,'UNET','Ours','Truth-center best dice')
# Heatmap(5,data[:,2], data[:,4], 20,'UNET','Validation','Truth-center best dice')
# Heatmap(6,data[:,4], data[:,6], 20,'Validation','Ours','Truth-center best dice')

# Heatmap(1,data[:,1], data[:,5], 50,'UNET','Ours','SBD',log=False,cmap='default')
# Heatmap(2,data[:,1], data[:,3], 50,'UNET','Validation','SBD',log=False,cmap='default')
# Heatmap(3,data[:,3], data[:,5], 50,'Validation','Ours','SBD',log=False,cmap='default')

# Heatmap(1,data[:,2], data[:,6], 20,'UNET','Ours','DIC',log=False,cmap='default')
# Heatmap(2,data[:,2], data[:,4], 20,'UNET','Validation','DIC',log=False,cmap='default')
# Heatmap(3,data[:,4], data[:,6], 20,'Validation','Ours','DIC',log=False,cmap='default')

# +6
# Heatmap(1,data[:,7], data[:,15], 20,'UNET','Ours','Prediction-center best dice',log=False,cmap='default')
# Heatmap(2,data[:,7], data[:,11], 20,'UNET','Validation','Prediction-center best dice',log=False,cmap='default')
# Heatmap(3,data[:,11], data[:,15], 20,'Validation','Ours','Prediction-center best dice',log=False,cmap='default')
# Heatmap(4,data[:,8], data[:,16], 20,'UNET','Ours','Truth-center best dice',log=False,cmap='default')
# Heatmap(5,data[:,8], data[:,12], 20,'UNET','Validation','Truth-center best dice',log=False,cmap='default')
# Heatmap(6,data[:,12], data[:,16], 20,'Validation','Ours','Truth-center best dice',log=False,cmap='default')

# n = 1
Heatmap(1,data[:,1], data[:,5], 20, 'U-NET','With temporal module','SBD heatmap, instance number = 1',
        log = True, cmap = 'default')
# Heatmap(1,data[:,1], data[:,5], 20,'U-NET','test','SBD heatmap',log=True)


# scatter plot

def Scatter(id,xdata, ydata, xlabel, ylabel):
    plt.figure(id)
    plt.scatter(xdata, ydata, s = 1, c = 'b', marker = 'o', alpha = 0.5)
    plt.xlim([0, 1])
    plt.ylim([0, 1])
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)

# Scatter(4,data[:,1], data[:,5],'UNET','Ours')
# Scatter(5,data[:,1], data[:,3],'UNET','Validation')
# Scatter(6,data[:,3], data[:,5],'Validation','Ours')

# plt.show()

# find specific point
def FindPoint(id,xdata,ydata,region,xlabel,ylabel):
    print(xlabel + ' vs ' + ylabel + ':')
    for i in range(len(xdata)):
        if xdata[i] >= region[0] and xdata[i] <= region[1] and ydata[i] >= region[2] and ydata[i] <= region[3]:
            print(int(id[i]),xdata[i],ydata[i])

# FindPoint(data[:,0],data[:,3],data[:,5],[0,0.25,0,1],'Validation','Ours')
# FindPoint(data[:,0],data[:,3],data[:,5],[0,1,0,0.25],'Validation','Ours')
# FindPoint(data[:,0],data[:,1],data[:,5],[0,0.25,0,1],'UNet-prediction','Ours')

def Calculate(data):
    mean = np.mean(data)
    std = np.std(data)
    se = std / np.sqrt(len(data))
    return mean,std,se

for i in range(1,data.shape[1]):
    print(Calculate(data[:,i]))