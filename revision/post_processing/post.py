import numpy as np
from sklearn.manifold import TSNE, MDS, locally_linear_embedding, SpectralEmbedding, Isomap
import umap

class PostProcess():
    def __init__(self, mask, prediction):
        """
        args:
            mask: (int list): vessel mask to select the embedding (1 for vessel, 0 for background)
            prediction: (numpy array): the prediction of the model (embedding space dimension, height, width)
        """
        self.mask = mask
        self.prediction = prediction
        # embedding is the selected embedding space corresponding to the vessel mask
        self.embedding = self.prediction[:, self.mask].transpose(1, 0)
        # embedding_2d is the 2d embedding generated by decreasing the dimension of original embedding
        # acquires the 2d embedding by excuting the Visulization function
        self.embedding_2d = None

    def Clustering(self, method = 'meanshift', embedding_type = 'original', ratio = 1/4):
        """
            Clustering the embedding space
            args:
                method: (str): the clustering method
                embedding_type: (str): the type of embedding space ('original' or '2d')
                ratio: (float): the ratio to adjust the bandwidth of the MeanShift clustering
        """
        if embedding_type == 'original':
            embedding = self.embedding
        elif embedding_type == '2d' and self.embedding_2d is not None:
            embedding = self.embedding_2d
        else:
            print('Please generate 2d embedding first by using the function Visualization')
            print('or choose the original embedding')
            return

        if method == 'meanshift':
            from sklearn.cluster import MeanShift, estimate_bandwidth

            bandwidth = estimate_bandwidth(embedding, quantile = 1)
            # I observed that the estimated bandwidth usually is too large, so I decrease it by a ratio
            bandwidth_adjust = bandwidth * ratio
            #print('bandwidth: %.4f' % bandwidth_adjust)
            ms = MeanShift(bandwidth = bandwidth_adjust, bin_seeding = True)

            try:
                result = ms.fit(embedding)
            except:
                result = 0
            # if it fails to converge, re-adjust the bandwidth to a larger value
            while result == 0:
                bandwidth_adjust = bandwidth_adjust * 1.1
                print('Re-adjusted bandwidth: %.4f' % bandwidth_adjust)
                ms = MeanShift(bandwidth = bandwidth_adjust, bin_seeding=True)
                try:
                    result = ms.fit(embedding)
                except:
                    result = 0

            self.label_predict = ms.labels_
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            #print("number of estimated clusters : %d" % self.ins_number)

        elif method == 'kmeans':
            from sklearn.cluster import KMeans
            # need first input ins_number
            clustering = KMeans(self.ins_number).fit(embedding)
            self.label_predict = clustering.labels_

        elif method == 'AffinityPropagation':
            from sklearn.cluster import AffinityPropagation
            # meet problem when using AffinityPropagation
            clustering = AffinityPropagation(random_state=5).fit(embedding)
            self.label_predict = clustering.labels_
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            print("number of estimated clusters : %d" % self.ins_number)

        elif method == 'SpectralClustering':
            from sklearn.cluster import SpectralClustering
            clustering = SpectralClustering(n_clusters = self.ins_number, assign_labels = 'discretize', random_state = 0).fit(embedding)
            self.label_predict = clustering.labels_
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            print("number of estimated clusters : %d" % self.ins_number)

        elif method == 'AgglomerativeClustering_ward':
            from sklearn.cluster import AgglomerativeClustering
            # linkage{‘ward’, ‘complete’, ‘average’, ‘single’}, default =’ward’
            clustering = AgglomerativeClustering(linkage = 'ward').fit(embedding)
            self.label_predict = clustering.labels_
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            print("number of estimated clusters : %d" % self.ins_number)

        elif method == 'AgglomerativeClustering_single':
            from sklearn.cluster import AgglomerativeClustering
            clustering = AgglomerativeClustering(linkage = 'single').fit(embedding)
            self.label_predict = clustering.labels_
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            print("number of estimated clusters : %d" % self.ins_number)

        elif method == 'DBSCAN':
            # meet problem when using DBSCAN
            from sklearn.cluster import DBSCAN
            clustering = DBSCAN(eps = 3, min_samples = 2).fit(DBSCAN)
            self.label_predict = clustering.labels_
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            print("number of estimated clusters : %d" % self.ins_number)

        elif method == 'OPTICS':
            from sklearn.cluster import OPTICS
            clustering = OPTICS(min_samples=2).fit(embedding)
            self.label_predict = clustering.labels_
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            print("number of estimated clusters : %d" % self.ins_number)

        elif method == 'Birch':
            from sklearn.cluster import Birch
            brc = Birch(n_clusters=self.ins_number)
            self.label_predict = brc.predict(embedding)
            labels_unique = np.unique(self.label_predict)
            self.ins_number = len(labels_unique)
            print("number of estimated clusters : %d" % self.ins_number)

        #print('Clustering done!')
        return self.label_predict

    def GroundTruthLabel(self, ins_groundtruth):
        """
            Get the ground truth label for embedding space
            args:
                ins_groundtruth: (np.array): the ground truth label for instances (instance id, height, width)
        """
        self.label_gt = ins_groundtruth[:, self.mask]
        return self.label_gt

    def Visualization(self, method = 'UMAP'):
        """
            Visualize the embedding space in 2D
            Notice that Visualization is slow
            args:
                method: (str): the method to visualize the embedding space
        """
        if method == 'MDS':
            embedding = MDS(n_components=2)
            self.embedding_2d = embedding.fit_transform(self.embedding)
        elif method == 'TSNE':
            tsne = TSNE(n_components=2)
            self.embedding_2d = tsne.fit_transform(self.embedding)
        elif method == 'UMAP':
            fit = umap.UMAP(n_components=2)
            self.embedding_2d = fit.fit_transform(self.embedding)
        elif method == 'Spectral':
            embedding = SpectralEmbedding(n_components=2)
            self.embedding_2d = embedding.fit_transform(self.embedding)
        elif method == 'LLE':
            self.embedding_2d, squared_errorfloat = locally_linear_embedding(self.embedding,
                                                                             n_components=2, n_neighbors=10)
        elif method == 'Hessian':
            self.embedding_2d, squared_errorfloat = locally_linear_embedding(self.embedding,
                                                                             n_components=2, n_neighbors=50)
        elif method == 'LTSA':
            self.embedding_2d, squared_errorfloat = locally_linear_embedding(self.embedding,
                                                                             n_components=2, n_neighbors=10, method = 'ltsa')
        elif method == 'Isomap':
            embedding = Isomap(n_components = 2)
            self.embedding_2d = embedding.fit_transform(self.embedding)

        print('Visualization done!')
        return self.embedding_2d

    def InstanceLayer(self):
        """
            organize the label_predict into instance layer
            self.label_predict generated by self.Clustering
        """
        for i in range(self.ins_number):
            single = np.zeros_like(self.label_predict, dtype=np.uint8)
            single[self.label_predict == i] = 1

            # height * weight
            single_instance_mask = np.zeros_like(self.mask, dtype = np.uint8)
            single_instance_mask[self.mask] = single

            single_instance_mask = np.expand_dims(single_instance_mask, axis = 0)

            if i == 0:
                collection = single_instance_mask
            else:
                collection = np.concatenate([collection, single_instance_mask], axis = 0)

        # collection: instance_number * height * width
        # 1 for the instance, 0 for the background
        return collection

    def InstanceMap(self):
        """
            Generate the instance map from self.label_predict
            another version of InstanceLayer
        """

        ins_map = np.zeros_like(self.mask, dtype=np.uint8)
        for i in range(self.ins_number):
            single = np.zeros_like(self.label_predict, dtype=np.uint8)
            single[self.label_predict == i] = i + 1
            ins_map[self.mask] += single

        # img_ins: width * height (with value 0[background], 1 to max instance number, representing different instances)
        img_ins = np.squeeze(ins_map)
        return img_ins

def Coloring(ins_mask, colormap, type):
    """
        Coloring the mask with colormap
        args:
            mask: (np.array): the mask to be coloredc
            colormap: (function): the colormap function
            type: (str): the type of mask
    """

    if type == 'label_list':
        # mask is numpy and H * W with different label number
        # could generated by InstanceMap
        ins_color_img = np.zeros((ins_mask.shape[0], ins_mask.shape[1], 3), dtype=np.uint8)
        n_ins = max(np.unique(ins_mask)).astype(np.int)

        # extract the color for each instance in colormap
        # modify it when changing the colormap function
        colors = [colormap(each) for each in range(0, n_ins)]

        for i in range(n_ins):
            ins_color_img[ins_mask == i + 1] = \
            (np.array(colors[i][:3]) * 255).astype(np.uint8)
    elif type == 'image_channel':
        # mask Channel * H * W
        # could generated by InstanceLayer
        ins_color_img = np.zeros((ins_mask.shape[1], ins_mask.shape[2], 3), dtype=np.uint8)
        n_ins = ins_mask.shape[0]
        mask = ins_mask.transpose(1,2,0)
        # mask is numpy and H * W * Channel

        # extract the color for each instance in colormap
        # modify it when changing the colormap function
        colors = [colormap(each) for each in range(0, n_ins)]

        for i in range(n_ins):
            ins_color_img[mask[:,:,i] != 0] =\
            (np.array(colors[i][:3]) * 255).astype(np.uint8)

    return ins_color_img, colors

def ChannelToLabel(channel):
    """
        Convert the channel to label (without background id 0)
        args:
            channel: (np.array): Channel * H * W
    """
    # label: H * W -> H*W, (remove background and dimension 1)
    label = np.zeros((channel.shape[1], channel.shape[2]), dtype=np.uint8)
    for i in range(channel.shape[0]):
        label[channel[i,:,:] != 0] = i + 1 # exist some channel is empty
    # make shape as one dimension
    label = np.squeeze(label)
    # remove 0 from list
    label = label[label != 0]
    return label

